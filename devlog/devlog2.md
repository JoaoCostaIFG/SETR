# uKernel DevLog #1

I'm currently enrolled in a class about embedded and real-time systems. For this
class's final project, I'm developing a real-time kernel for
[Arduino UNO](https://www.arduino.cc/en/Main/arduinoBoardUno). I'll try to
document the development in a series of posts. This is part #1.

On the last chapter, we've talked about basic concepts of real-time systems.
Now, we'll talk about implementing multiple stacks, one for each task.

## Why multiple stacks?

There are two reaons for us to want to implement a system where each task has
its own stack:

1. In the future, we'll implement mutexes which can lead to tasks being in a
   blocked state (priority inversion);
2. We want our task functions to follow the prototypes of POSIX thread
   functions: `void* task(void* arg)`.

On this devlog, we'll focus on the second one.

### The new task functions

Originally, a task for toggling an LED could look something like this:

```c
// toggles an LED
void runTask() {
  digitalWrite(LEDPIN, !digitalRead(LEDPIN));
}
```

This function would be called for each activation of the task. Alongside this
function, we would also benefit from hacing a _setup_ function for each task,
that would be called whenever the task is created:

```c
// setup the LED pin as OUTPUT and turn the LED on
void setupTask() {
  pinMode(LEDPIN, OUTPUT);
  digitalWrite(LEDPIN, HIGH);
}
```

The plan is to join these methods (and the multiple calls to `runTask`) into a
single method, that is called once:

```c
void taskFunc(void *arg) {
  // set pin as output
  pinMode(LEDPIN, OUTPUT);
  digitalWrite(LEDPIN, HIGH); // turn on LED

  while (true) {
    // toggle LED
    digitalWrite(LEDPIN, !digitalRead(LEDPIN));

    Sched_Yield(); // finished execution for this activation
  }
}
```

In order for the function to only be called once, we wrap the contents that need
to run on each activation into a `while(true)` loop.  
**Note:** contrary to what POSIX threads, we return void from these functions,
because they aren't meant to _end_.

## Implementation

Now it's time for us to talk about how to implement this system. It should be
noted that much of this ideas were taken from the documentation and code
developed for [FreeRTOS](https://freertos.org). The assembly code examples were
also taken from their documentation (with some slight changes).

### The stacks

As of now, each task has a _task control block_ (TCB): a class containing the
execution information of a task. The TCB of each task contains the stack of the
given task. A task's stack is just an array of bytes (`unsigned char`). It is
possible to calculate the maximum stack size needed for each task, but for now,
we'll just assume it is always big enough for our needs.

```cpp
typedef unsigned char byte;

class Task {
  (void*) taskFunc(void *);   // task's code
  const unsigned int period;  // task's period
  unsigned int delay;         // time left until next activationthe
  byte stack[BIG_ENOGH];      // task's stack

  /* ... */
};
```

### Context switching

Whenever a task is blocked, preempted, or finishes the current activation, we
need to suspend its execution. When we do this, we need to **save its context**,
so we can restore it later.

**Saving a task's context** implies saving: its program counter (`PC`), the
state of the CPU's general purpose registers (32 registers, from `R0` to `R31`),
the CPU's status register (`SREG`), the stack pointer (2 registers, `SPH` and
`SPL`), and the contents of the stack.

Let's focus our discussion on the situation where a task is preempted, because
of a timer interrupt. Interrupt handlers (ISR) are functions with some special
properties:

- Registers modified inside an ISR are restored to their original value (the
  value on ISR entry) on exit;
- Interrupts are disabled on ISR entry;
- ISRs end with a `RETI` (return from interupt) instruction, instead of the
  usual `RET` (return) instruction. This instruction re-enables interrupts on
  ISR exit.

The fact that the registers modified inside the ISR are saved and restored
automatically isn't enough for our use case, because during preemption other
registers can be modified by new running task, without the compiler knowing.
Still, this is interesting, because we can look at the code disassembly and
learn how to save registers.

```asm
; ---------------------------------------
; CODE GENERATED BY THE COMPILER TO SAVE
; THE REGISTERS THAT GET ALTERED BY THE
; APPLICATION CODE DURING THE ISR.
PUSH    R1
PUSH    R0
IN      R0,0x3F
PUSH    R0
CLR     R1
PUSH    R18
PUSH    R19
PUSH    R20
PUSH    R21
PUSH    R22
PUSH    R23
PUSH    R24
PUSH    R25
PUSH    R26
PUSH    R27
PUSH    R30
PUSH    R31
; ---------------------------------------

CALL 0x0000029B ; Call a subroutine

; ---------------------------------------
; CODE GENERATED BY THE COMPILER TO
; RESTORE THE REGISTERS PREVIOUSLY
; SAVED.
POP     R31
POP     R30
POP     R27
POP     R26
POP     R25
POP     R24
POP     R23
POP     R22
POP     R21
POP     R20
POP     R19
POP     R18
POP     R0
OUT     0x3F,R0
POP     R0
POP     R1
RETI
; ---------------------------------------
```

As we can see, the code to save and the code to restore the registers is very
similar: we start by pushing the registers, and then pop them in the oposite
order.

**Note:** The behaviour described above is cause by GCC's _signal_ attribute. In
arduino, we can declare an ISR for _timer1_ as `ISR(TIMER1_COMPA_vect);`. This
automatically includes the _signal_ attribute. In some other applications you
might need to do something like this:
`void SIG_TIMER1_COMPA_vect(void) __atribute__ (( signal ));`.

#### GCC's _naked_ attribute

If we add code to save all registers, this would result in some registers being
saved twice: once by the compiler generated code, and again by our code. To
avoid this, we use GCC's _naked_ attribute. This attribute tells the compiler to
not generate any function entry (_prologue_) or exit (_epilogue_) code for the
given function. When using the _naked_ attribute, the compiler generates the
following code:

```asm
; ------------------------------------------------
; NO COMPILER GENERATED CODE TO SAVE THE REGISTERS
; ------------------------------------------------

CALL 0x0000029B ; Call a subroutine

; ------------------------------------------------
; NO COMPILER GENERATED CODE TO RESTOR THE
: REGISTERS OR RETURN FROM THE ISR
; ------------------------------------------------
```

As we can see, now the compiler generates neither the code to save/restore the
registers, nor the instruction to return from the ISR. With this, we can safely
add our code to save and restore the context (don't forget the return
instruction):

```c
ISR(TIMER1_COMPA_vect) __atribute__ (( naked ));

ISR(TIMER1_COMPA_vect) {
  // macro that explicitly saves the execution context
  SAVE_CONTEXT();

  handleTick(); // handle the timer tick

  // macro that explicitly restores the execution context
  SAVE_CONTEXT();

  // return from interrupt
  asm volatile ( "reti" );
}
```

### Saving the context

The following macro is responsible for saving the execution context. Note that
the variable `currStack` contains the memory address of the current stack's
stack pointer. We can think of it as a _pointer to the stack pointer_, which in
turn points to the top of the stack. In the case of Arduino UNO, pointers are
16-bit wide, 1 byte for each Stack Pointer register (`SPH`, `SPL`).

```c

#define SAVE_CONTEXT()                \
asm volatile (                        \
  "push  r0                     \n\t" \ (1)
  "in    r0, __SREG__           \n\t" \ (2)
  "cli                          \n\t" \ (3)
  "push  r0                     \n\t" \ (4)
  "push  r1                     \n\t" \ (5)
  "clr   r1                     \n\t" \ (6)
  "push  r2                     \n\t" \ (7)
  "push  r3                     \n\t" \
  "push  r4                     \n\t" \
  "push  r5                     \n\t" \

    :
    :
    :

  "push  r30                    \n\t" \
  "push  r31                    \n\t" \
  "lds   r26, currStack         \n\t" \ (8)
  "lds   r27, currStack + 1     \n\t" \ (9)
  "in    r0, __SP_L__           \n\t" \ (10)
  "st    x+, r0                 \n\t" \ (11)
  "in    r0, __SP_H__           \n\t" \ (12)
  "st    x+, r0                 \n\t" \ (13)
)
```

- We save `R0` (`__tmp_reg__`) first (**1**), because it is used when saving the
  status register (`SREG`);
- We move `SREG` to `R0` (**2**), so we can push it to the stack later (**4**);
- After saving `SREG`, we disable interrupts. It is important that we save
  interrupts as soon as possible. We do this after saving `SREG`, because that's
  where the information about interrupts being enabled/disabled is stored.
  Although we're just analysing the case where a task is preempted, because of a
  timer interrupt, there are other cases where we need to use this macro (task
  blocking, sleeping, yielding), so we need to disable interrupts explicitly;
- The compiler assumes that `R1` (`__zero_reg__`) to be zero. We save (**5**)
  its value before clearing (**6**) it;
- Between (**7**) and (**8**), we save all general purpose registers in
  numerical order (from `R2` to `R31`);
- In (**8**) and (**9**) we take the address of where we store the stack pointer
  and store it in registers `R26` and `R27` (`x+` register). This is done, so we
  can take then take the _low byte_ (**10** and **11**) and the _high nibble_
  (**12** and **13**) of the stack pointer and store it there

### Restoring the context

The process to restore the context is similar to the one to save it: we mainly
just pop the registers we pushed while saving the context in the reverse order.

```c
#define RESTORE_CONTEXT()             \
asm volatile (                        \
  "lds  r26, currStack          \n\t" \ (1)
  "lds  r27, currStack + 1      \n\t" \ (2)
  "ld   r28, x+                 \n\t" \
  "out  __SP_L__, r28           \n\t" \ (3)
  "ld   r29, x+                 \n\t" \
  "out  __SP_H__, r29           \n\t" \ (4)
  "pop  r31                     \n\t" \
  "pop  r30                     \n\t" \

    :
    :
    :

  "pop  r1                      \n\t" \
  "pop  r0                      \n\t" \ (5)
  "out  __SREG__, r0            \n\t" \ (6)
  "pop  r0                      \n\t" \ (7)
)
```

- As mentioned above, `currStack` contains the address from where the stack
  pointer can be retrieved. It is loaded into the `x+` register (**1** and
  **2**);
- The stack pointer is loaded into registers `R28` and `R29`, and then loaded to
  the stack pointer registers (`SPH`, `SPL`);
- All the general purpose registers are poped from the stack in the reverse
  order that they were push in;
- While saving the context, the status register (`SREG`) was pushed between `R0`
  and `R1`. We restore it before restoring `R0`.

### Program counter

When an interrupt occurs, the program counter (`PC`) is automatically placed on
the stack.
