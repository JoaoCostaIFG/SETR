#include <Arduino.h>

#include "include/scheduler.h"
#include "include/context.h"

#define NT 20

// tasks
Task* tasks[NT]; // lower int => higher task priority
volatile unsigned int curr_task = NT;
// stack
volatile TCB_t* volatile currentStack = nullptr;

void Sched_SetupTimer() {
  noInterrupts();

  /* configure time */
  SCHEDULER_TCCRXA  = 0;
  SCHEDULER_TCCRXB  = 0;
  SCHEDULER_TCNT    = 0;
  // freq (s) = CMR / (clock / prescaler) = CMR / (16MHz / prescale).
  SCHEDULER_OCRXA   = 31250;                // Compare Match Register (CMR)
  SCHEDULER_TCCRXB |= SCHEDULER_PRESCALER;  // 256 prescaler
  SCHEDULER_TCCRXB |= (1 << WGM12);         // CTC mode
  SCHEDULER_TIMSK  |= (1 << OCIE1A);        // enable timer compare interrupt

  interrupts();
}

void Sched_Init() {
  for (auto& task: tasks)
    task = nullptr;
}

void Sched_Start () {
  Serial.println("Start");

  Sched_SetupTimer();

  // restore context of the first task to run
  RESTORE_CONTEXT();

  /* Simulate a function call end as generated by the compiler. We will now
  jump to the start of the task the context of which we have just restored. */
  __asm__ __volatile__ ( "ret" );

  /* UNREACHABLE */
  return;
}

int Sched_Add(Task* t) {
  int prio = t->getPrio();
  if (!tasks[prio]) {
    tasks[prio] = t;
    if (currentStack == nullptr) {
      Serial.println("First task");
      currentStack = t->getStackAddr();
    }
    return prio;
  }
  return -1;
}

void Sched_Dispatch() {
  Serial.println("Dispatch");

  unsigned int prev_task = curr_task;

  for (unsigned int i = 0; i < prev_task; ++i) {
    Task* t = tasks[i];
    if (!t || !t->isReady())
      continue;

    t->setReady(false);

    // run task
    curr_task = i;
    currentStack = t->getStackAddr(); // set current stack
    interrupts();
    // t->run(); // TODO
    noInterrupts();
    curr_task = prev_task;

    // delete one-shot
    if (t->getPeriod() == 0) {
      tasks[i] = nullptr;
    }
  }

  // restore pointer to previous stack
  /*
  currentStack = (prev_task < NT && tasks[prev_task]) ?
                 tasks[prev_task]->getStackAddr() :
                 baseStack;
  */
}


int Sched_Schedule() {
  Serial.println("Schedule");

  int readyCnt = 0;
  for (int i = 0; i < NT; ++i) {
    Task* t = tasks[i];
    if (!t) continue;

    if (t->isReady()) { // ready tasks are already scheduled
      ++readyCnt;
      continue;
    }

    if (t->getDelay() > 0) {
      t->tick();
    } else {
      t->setReady(true);
      ++readyCnt;
      t->reset();
    }
  }

  return readyCnt;
}

void Sched_ManualCtxSwitch() {
  /* explicitly save the execution context */
  SAVE_CONTEXT();

  // dispatch
  Sched_Dispatch();

  /* explicitly restore the execution context */
  RESTORE_CONTEXT();

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}

void Sched_CtxSwitch() {
  /* explicitly save the execution context */
  SAVE_CONTEXT();

  // sched + dispatch
  /* TODO
  if (Sched_Schedule() > 0) {
    Sched_Dispatch();
  }
   */

  /* explicitly restore the execution context */
  RESTORE_CONTEXT();

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}
