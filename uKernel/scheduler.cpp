#include <Arduino.h>
#include <limits.h>

#include "include/scheduler.h"
#include "include/context.h"
#include "include/task.h"

// TODO periods can't be higher than this number
#define MAXTIME UINT_MAX/2
#define NT 20

// TODO delete one-shot

void idleTaskFunc(void* arg) {
  while (true) {
#ifdef DEBUG
    //Serial.println("In idle");
#endif
    //delay(1000);
    ;
  }
};

// tasks
static int nTasks = 0;
static Task* tasks[NT]; // lower index => higher task priority
static volatile Task* curr_task;
// idle task
static Task* idleTask = new Task(&idleTaskFunc, (void*) 0, 64);
// stack
volatile TCB_t* volatile currentStack = nullptr;

void Sched_SetupTimer() {
  noInterrupts();

  /* configure time */
  SCHEDULER_TCCRXA = 0;
  SCHEDULER_TCCRXB = 0;
  SCHEDULER_TCNT = 0;
  // freq (s) = CMR / (clock / prescaler) = CMR / (16MHz / prescale).
  SCHEDULER_OCRXA = 31250;                  // Compare Match Register (CMR)
  SCHEDULER_TCCRXB |= SCHEDULER_PRESCALER;  // 256 prescaler
  SCHEDULER_TCCRXB |= (1 << WGM12);         // CTC mode
  SCHEDULER_TIMSK |= (1 << OCIE1A);         // enable timer compare interrupt

  // TODO ?
  interrupts();
}

void Sched_Init() {
  for (auto& task: tasks)
    task = nullptr;

  Sched_Add(idleTask);
}

void Sched_SortTasks() {
  qsort(tasks, nTasks, sizeof(Task*), compareTask);
}

void Sched_SetCurrTask(Task* newCurrTask) {
  curr_task = newCurrTask;
  currentStack = newCurrTask->getStackAddr(); // set current stack
}

void Sched_Start() {
#ifdef DEBUG
  Serial.println("Start");
#endif

  Sched_SortTasks();
  Task* firstTask = tasks[0];
  Sched_SetCurrTask(firstTask);

  Sched_SetupTimer();

  // restore context of the first task to run
  noInterrupts();
  RESTORE_CONTEXT();

  /* Simulate a function call end as generated by the compiler. We will now
  jump to the start of the task the context of which we have just restored. */
  __asm__ __volatile__ ( "ret" );

  /* UNREACHABLE */
  return;
}

//TODO: assert nTasks < NT
void Sched_Add(Task* t) {
  tasks[nTasks++] = t;
}

int Sched_Schedule() {
#ifdef DEBUG
  //Serial.println("Schedule");
#endif

  int readyCnt = 0;
  for (int i = 0; i < nTasks; ++i) {
    Task* t = tasks[i];
    if (!t) continue;

    if (t->isReady()) { // ready tasks are already scheduled
      ++readyCnt;
    }

    Serial.print(t->isReady() ? "ready " : "not ready ");
    Serial.print(t->getDeadline());
    Serial.print(" ");
    Serial.println(t->getDelay());

    if (t->getDelay() > 0) {
      t->tick();
    } else {
      t->setReady(true);
      ++readyCnt;
      t->reset();
    }
  }

  // sort priorities
  Sched_SortTasks();

  return readyCnt;
}

void Sched_Dispatch() {
#ifdef DEBUG
  //Serial.println("Dispatch");
#endif

  Task* nextTask = tasks[0];
  if (nextTask && nextTask->isReady() && nextTask != curr_task) {
    Sched_SetCurrTask(nextTask);
  }
}

void Sched_CtxSwitch() {
  SAVE_CONTEXT(); // save the execution context

  // sched + dispatch
  if (Sched_Schedule() > 1) {
    Sched_Dispatch();
  }

  RESTORE_CONTEXT(); // restore the execution context

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}

// Yielding
void Sched_YieldDispatch() {
#ifdef DEBUG
  Serial.println("Yield");
#endif

  curr_task->setReady(false);
  curr_task->nextDeadline();
  Sched_SortTasks();
  curr_task = nullptr; // can go to any task

  Sched_Dispatch();
}

void Sched_Yield() {
  SAVE_CONTEXT(); // save the execution context

  // dispatch
  Sched_YieldDispatch();

  RESTORE_CONTEXT(); // restore the execution context

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}
