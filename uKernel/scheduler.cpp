#include <Arduino.h>

#include "include/scheduler.h"
#include "include/context.h"

#define NT 20

void idleTaskFunc(void* arg) {
  while (true) {
    //Serial.println("In idle");
    //delay(1000);
    ;
  }
};

// tasks
Task* tasks[NT]; // lower int => higher task priority
static Task* idleTask = new Task(&idleTaskFunc, (void*) 0, 128, 1, 0, NT - 1);
volatile unsigned int curr_task = NT;
// stack
volatile TCB_t* volatile currentStack = nullptr;

void Sched_SetupTimer() {
  noInterrupts();

  /* configure time */
  SCHEDULER_TCCRXA = 0;
  SCHEDULER_TCCRXB = 0;
  SCHEDULER_TCNT = 0;
  // freq (s) = CMR / (clock / prescaler) = CMR / (16MHz / prescale).
  SCHEDULER_OCRXA = 31250;                // Compare Match Register (CMR)
  SCHEDULER_TCCRXB |= SCHEDULER_PRESCALER;  // 256 prescaler
  SCHEDULER_TCCRXB |= (1 << WGM12);         // CTC mode
  SCHEDULER_TIMSK |= (1 << OCIE1A);        // enable timer compare interrupt

  // TODO ?
  interrupts();
}

void Sched_Init() {
  for (auto& task: tasks)
    task = nullptr;

  Sched_Add(idleTask);
}

void Sched_Start() {
  Serial.println("Start");
  Serial.flush();

  Sched_SetupTimer();

  // restore context of the first task to run
  noInterrupts();
  RESTORE_CONTEXT();

  /* Simulate a function call end as generated by the compiler. We will now
  jump to the start of the task the context of which we have just restored. */
  __asm__ __volatile__ ( "ret" );

  /* UNREACHABLE */
  return;
}

int Sched_Add(Task* t) {
  int prio = t->getPrio();
  if (!tasks[prio]) {
    tasks[prio] = t;
    if (currentStack == nullptr || // first task (idle task)
        (t->getDelay() == 0 && prio < curr_task)) { // or, not offset task with higher prio
      // first task to run
      currentStack = t->getStackAddr();
      curr_task = prio;
    }
    return prio;
  }
  return -1;
}

void Sched_Dispatch() {
  Serial.println("Dispatch");

  unsigned int prev_task = curr_task;

  for (unsigned int i = 0; i < prev_task; ++i) {
    Task* t = tasks[i];
    if (!t || !t->isReady())
      continue;

    t->setReady(false);
    // run task
    curr_task = i;
    currentStack = t->getStackAddr(); // set current stack
    return;

    // delete one-shot
    // TODO
    /*
    if (t->getPeriod() == 0) {
      tasks[i] = nullptr;
    }
     */
  }
}

int Sched_Schedule() {
  Serial.println("Schedule");

  tasks[NT - 1]->setReady(true);

  int readyCnt = 1; // idle task is always ready
  for (int i = 0; i < NT - 1; ++i) {
    Task* t = tasks[i];
    if (!t) continue;

    if (t->isReady()) { // ready tasks are already scheduled
      ++readyCnt;
      continue;
    }

    if (t->getDelay() > 0) {
      t->tick();
    } else {
      t->setReady(true);
      ++readyCnt;
      t->reset();
    }
  }

  return readyCnt;
}

void Sched_ManualCtxSwitch() {
  /* explicitly save the execution context */
  SAVE_CONTEXT();

  // dispatch
  curr_task = NT; // can go to any task
  Sched_Dispatch();

  /* explicitly restore the execution context */
  RESTORE_CONTEXT();

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}

void Sched_CtxSwitch() {
  /* explicitly save the execution context */
  SAVE_CONTEXT();

  // sched + dispatch
  if (Sched_Schedule() > 1) {
    Sched_Dispatch();
  }

  /* explicitly restore the execution context */
  RESTORE_CONTEXT();

  // the return from function call must be explicitly added
  __asm__ __volatile__ ( "ret" );
}
